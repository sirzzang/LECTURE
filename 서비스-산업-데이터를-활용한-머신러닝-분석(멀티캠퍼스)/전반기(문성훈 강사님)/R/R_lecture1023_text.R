# 빅데이터란? 일반적으로 인식하는 빅데이터는 "많은 양의 데이터"라는 의미.
# 엄밀한 의미에서 주로 3가지를 이야기함.
# 3V: 빅데이터의 특징 - 1) volume: 데이터의 양(TB 이상, 일반적 속도로는 도저히 처리할 수 없음)
#                       2) velocity: 생성속도(데이터가 모여있지 않고 지속적으로 빠르게 생성되는 중.)
#                       3) variety: 데이터 종류 정형적이지 않고 매우 다양.
# 종류가 다양하고 크기가 매우 크며 매우 빠르게 생성되는 것 때문에 처리하기 굉장히 어려운 데이터.

# 일반적으로 빅데이터 처리는 문자열 처리를 동반하는 경우가 많음.

##########################################################################################

# raw data는 NA, null, string 잘려 오는 것도 있고 정규화도 안 되어 있고 쓸 수가 없음. 분석, 머신러닝 활용하기 쉽도록 전처리!
# 문자열의 경우도 추출, 결합 등의 처리 필요.
# 텍스트마이닝을 위해서도 중요.

###########################################################################################

# 문자열을 처리하기 적합한 외부 패키지: stingr package를 사용하면 쉽고 편하게 분석할 수 있음.

install.packages("stringr")
library(stringr)

var1 = "Honggildong1234Leess9032You25최길동2009"

# 1. 문자열의 길이를 구분해보아여!
str_length(var1)
  # 한글을 어떻게 처리하는지, 길이를 어떻게 처리할 것? # 유니코드: 한글, 영어 같은 크기.

# 2. 문자 위치를 찾아요
str_locate(var1, "9032")

    # 시작되는 위치의 첫 자와 마지막 자의 위치
    class(str_locate(var1, "9032"))
    # class: 자료구조 알려줌.
    mode(str_locate(var1, "9032")) #21, 24 이니까

# 3. 부분문자열을 구해보아요.
str_sub(var1, 3, 8)
  # 3번째부터 8번째 글자(시작과 끝 모두 inclusive)

# 4. 대소문자 변경
str_to_lower(var1)
str_to_upper(var1)
  # 한글은 대소문자 없으니 변경 ㄴㄴ

# 5. 문자열 교체
var2 = "Honggildong1234HongLeess9032You25최길동2009"
str_replace(var2, "Hong", "KIM") # 처음 찾은 거 하나만 바꿈
str_replace_all(var2, "Hong", "KIM")  # 매칭되는 거 전부 바꿈

# 6. 문자열 결합
var3 = "홍"
var4 = "길동"
str_c(var3, var4)

# 7. 문자열 분할
var1 = "Honggd1234,Leess9032,YOU25,최길동2009"
str_split(var1, ",") # COMMA  기준으로 분할해서 벡터로 뽑고 싶을 때.
  # split한 결과 보니까 [[1]]이 있는데, 수행해서 나온 결과에 key 값이 있네? list 형태다!
  # return 시 list 형태로 나온다!
class(str_split(var1, ","))
  # class를 통해 결과를 보면 명확하게 list 형태임을 알 수 있다.

# 8. vector 안에 있는 문자열 결합
var1 = c("홍길동", "김길동", "최길동")
str_c(var1) 
  # str_c가 문자열 결합하는 거니까, 이 함수 써봤는데 되나? 헐 안 된다ㅠㅠ
paste(var1, collapse = "")
paste(var1, "-")
paste(var1, collapse = " ")
paste(var1, collapse = "-")
  # 벡터 안의 글자 붙일 때는 str_c가 아니라 paste.
  # 어떤 separator 사용해서 붙일 것인지 두 번째 위치에 나타냄! "-"를 사용해서 이어붙인다.


#######################################################################################



# 문자열 처리를 쉽고 편하게 하기 위해서는 정규표현식(regular expression)
# 정규표현식: 정해져 있는, 약속된 규칙으로, 문자열 처리를 쉽고 편하게 할 수 있음. 문자열을 지칭하는 게 아니라, 문자의 패턴을 찾아주는 것. 문자를 표현하는 규칙.

# [a-z]: 영어 소문자 1개. / [A-Z]: 영어 대문자 1개.
# [가-힣]: 모든 한글. 전체 한글 코드표 통괄하는 표현.
# [0-9]: 숫자형 문자.
# {4} : comma 없으면 몇 번 반복할 것인지의 의미. / {2,} : 2개 이상./ {2,3}: 2개 이상 3개 이하.
# ^ : not의 의미.
# 반드시 나와야 하는 기호는 그냥 써주면 됨. ex) "[0-9]{6}-" : 숫자 6개, 그 다음에 바로 dash 기호 나와야 한다!
# [1234]: 1234 중 하나가 나와야 한다. 대괄호가 한 글자를 의미하니까!

var1 = "Honggd1234,Leess9032,YOU25,최길동2009"; var1

# 정규표현식을 이용해 내가 원하는 문자열 추출하고 싶다면?

str_extract_all(var1, "[a-z]{4}") 
  # 조건에 부합되는 문자열 전부 추출. 두 번째 칸에 정규표현식을 넣음. 그러면 그 정규표현식 규칙에   맞는 문자를 뽑아냄.
  # [a-z]{4} : 영어 소문자 1개가 연속적으로 4번 반복되는 문자열 추출.
str_extract(var1,"[a-z]{4}")
  # 조건에 부합되는 문자열 중 첫 번째 문자열을 추출. str_extract_all이 모두 추출했떤 것과 다름.
  # str_extract_all은 return이 list 형태로 떨어지는데, str_extract는 그렇지 않음.
str_extract(var1, "[A-Z]{2}")
str_extract_all(var1, "[a-z]{2,}")
  # [a-z]{2,}: comma는 "이상"의 의미이므로, 영어 소문자가 2개 이상 나오는 것을 추출함.
str_extract_all(var1, "[a-z]{2,3}")
  # 2개 이상 3개 이하로 추출하니까, ong 먼저 3개로 추출. 그 이후에 남은 게 gd로 2개 이상에 부합하니까 추출. ess 3개까지 가니까 추출. 
str_extract_all(var1, "34")
  # 이런 문법으로 쓰면 그냥 저기서 "34" 열을 추출. 찾아줌.

# 한글을 찾아보고 싶다면?
  # 아스키 코드 영어, 특수문자, 한글만 인식됨 -> 다국어 표현을 위해 문자표 늘린 게 유니코드.
  # 그런데 R은 유니코드 지원하지 않음.
# 어쨌든 한글 추출하려면, 한글도 코드화되어서 숫자로 표현됨. 결국 한글의 시작과 끝을 알아야 함.
# 한글 지칭하는 정규표현식: [가-힣]

str_extract_all(var1, "[가-힣]{2,}")
  # [가-힣]{2,}: 한글 2번 이상 반복되는 것 모두 추출.

# 숫자형 문자를 추출하고 싶다면?
  # 숫자문자: [0-9]
str_extract_all(var1, "[0-9]{2}")
str_extract(var1, "[0-9]{2}")
str_extract_all(var1, "[0-9]{2,}")
str_extract(var1,"[0-9]{1,3}")

# 한글을 제외한 나머지 문자 추출?
  # not이라고 해서 ! 쓰는 게 아니라 ^(hat)을 사용한다.
str_extract_all(var1,"[^가-힣]{5}")
  # 한글 아닌 게 5글자 있는 것 찾아주셈.
str_extract_all(var1, "[^a-z]{2}")
str_extract(var1, "[^A-Z]{5}")


##################################################################

# 주민등록번호 유효성 검사
myID = "950123-2682015954621"; myID
str_extract_all(myID, "[0-9]{6}-[1234][0-9]{6}")
  # 정규표현식 사용해서 검사하는 pattern 만들어야 한다.
  # 잘못 입력해도 위에 작성한 것처럼 regular expression 이용하면 끊을 수 있음.
