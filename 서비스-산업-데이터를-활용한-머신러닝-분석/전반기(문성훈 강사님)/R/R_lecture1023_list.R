####### LIST #####

# 1차원 선형구조, 다른 데이터 타입이 들어올 수 있음.
# 정확, 엄밀히 표현하면 "중첩 자료구조": 하나의 자료구조를 다른 자료구조 안에 포함시키기 위해 사용. 많은 양의 데이터, 다양한 종류의 데이터를 하나의 묶음으로 묶기 위해 사용.
# 1차원 선형구조인데, 내부적으로 map 구조 = key와 value의 쌍으로 자료를 저장하는 자료구조. 이런 게 선형구조, 배열 형태로 구성되어 있음. 배열 형태로 map들이 구성되어 있음.

# 지금까지 했던 여러 자료구조들을 생성해서 LIST 안에 저장해보아요!
# list 안에는 첫째 칸에 벡터, 둘째 칸에 array, 셋째 칸에 matrix 등 여러 가지 다양한 자료 구조 저장 가능.

var_scalar = 100; var_scalar # 스칼라: 값이 하나인 변수, 벡터인데 공간이 1개인 벡터. 원래 벡터는 공간이 여럿.
var_vector = seq(from = 10, to = 30, by = 10); var_vector # 벡터: c, seq, rep 사용해볼 것.
var_matrix = matrix(rep(1:12), ncol=3, nrow=4, byrow = T); var_matrix # 행렬 : 행 단위로 채움, 4행 3열 행렬.
var_array = array(c(1:12), dim=c(2, 2, 3)); var_array # array는 3차원 이상이기 때문에 몇 차원인지 알려줘야 함. 벡터의 개수가 차원이고, 각각의 개수가 행, 열, 면의 개수.각 차원의 벡터의 length가 3(2, 2, 3)이므로 3차원. 3차원 array가 만들어지고 행이 2행, 열이 2열, 면이 3면. 
var_df = data.frame(id=1:4, name=c("홍길동", "김길동", "이길동", "최길동"), age=c(30,40, 20, 10)) # data frame: 2차원 구조, matrix와 비슷하지만 데이터 구조가 다르다고 보면 됨. 일반적으로 자료를 외부에서 얻으면 어떤 것은 문자, 어떤 것은 숫자 등 다양한 구조로 되어 있음. 다양한 형태의 데이터를 처리하기 위해서는 matrix보다 data frame이 좀 더 나음.
  # 그럼 matrix 말고 data frame 쓰지 왜 matrix 사용? 속도가 빠름. 대표적으로 이미지 처리가 숫자인데 필터링 처리하거나 이미지를 분석하는 등 하는 게 전부 숫자 처리. 당연히 2차원 matrix 사용해서 처리하는 게 더 빠름. 굳이 data frame 만들어서 처리할 필요는 없다. 
 # data frame 만드는 함수: data.frame
 # 각각의 열이 다른 data type으로 구성될 수 있음. 그래서 column을 명시해줘야 함.
 # data frame 구성하면 앞에 index 번호 [] 안에 붙어서 나옴.

# 이런 data 구조들 모두 모아서 list 만들어보자!

myList=list(var_scalar, 
            var_vector, 
            var_matrix, 
            var_array, 
            var_df)
# 1차원 자료구조를 여러 개 저장할 수 있는 자료 구조.


myList
# 실행해보면 출력된 결과가 밑에 좀 신기하기 나옴. [[1]], [[2]], [[3]] 등. 안에 들어 있는 모든 자료구조와 데이터 출력.
 # 중첩자료구조: 다른 자료구조를 내부적으로 가질 수 있는 자료구조.
# list 는 선형자료구조이므로 index를 사용해서 이용할 수 있음.
# index 사용한 access 방식.

myVector = c(10, 20, 30)
myVector[2] # 괄호 안에 여러 개 올 수 2:3 등 다양하게 와서 index로 사용 가능.

# List도 가능.
myList[1] # 출력 결과 보면, 우린 원래 100이라는 스칼라 넣어놧는데 이렇게 list에서 찾으면 100만 나오는 게 아니라 [[1]]도 같이 나옴. : [[1]]은 key값. 첫 번째 칸에 들어가 있는 데이터에 대한 키.
#data를 출력할 때 key도 같이 출력됨. # 데이터 저장 시 그냥 저장하는 게 아니라 key를 이용해서 자료를 저장하는 형태. 
# [[1]]은 key값을 지정하지 않았을 때. 그냥 저 순서. index 번호. key값이 없어서. 첫 번째 방에 key를 따로 지정하지 않아서 저렇게 잡혀 있음. 
# 따라서 위와 같은 공간에서 key를 잡지 않고 안의 공간을 전체 다 불러오면 key와 자료가 같이 도출.
myList[[1]] # key를 이용해서 access하겠따는 의미 : 100만 도출.

myList # list를 전체 다 보여주는 것.
myList[1] # key와 value 모두 나옴. 공간 access. vector처럼 순서 이용해서 첫 번째 방을 다 불러옴.
myList[[1]] # 공간 안에 들어가서 딱 하나의 key만 지정해서 key에 해당하는 값을 다 보여줌. key이름이 지정되어 있지 않아서 [[1]]일 뿐.
myList[2]
myList[[2]]
myList[3]
myList[[3]]


##############################################

# list는 일반적으로 key 값을 지정해서 만들 수 있는데. key 값을 이용해서 어떤 식으로 access할 수 있는지 볼게요!

myList= list(name=c("홍길동", "김길동"),
             age=seq(20, 30, by = 10),
             address=c("서울", "부산"))

#list의 length(size)는 3, 각각의 value/data에 key값이 부여되어 있음.
# name이라는 이름으로 이런 데이터를 첫 번째 방에 넣을거야! 위에서 만든 데이터와 차이가 나는 것은 아까는 그냥 벡터를 첫 번째 방에다가 넣었을 뿐인데, 여기서는 key와 value의 쌍으로 넣은 것일 뿐.


myList
# [] 안에 1, 2, 3 대신에 name, address, key 값이 나옴.

myList[1]
# 첫 번째 방을 소환한다! 첫 번째 방에 있는 key와 value가 같이 튀어나옴. 대괄호 하나는 방에 있는 애를 access하는 것.

myList$name
# key값으로 access함. name에 해당하는 vector만 나옴.
# list에서 key값으로 access할 때는 $기호 사용.
# name에 해당하는 벡터가 나옴.
myList$name[2]
# name 벡터에서 두 번째에 있는 애를 소환해라!
myList[[1]] # 첫 번째 공간의 key에 해당하는 애 소환: key가 name인 애들 소환하겠지 당연히?
# key 이름이 지정되어 있더라도, name을 알려주지 않아도 이런 방식으로도 소환 가능.
myList[["name"]] # key이름이 "name"인 애 전부 다 가져와!
myList$name # 그럼에도 불구하고 이 방식이 제일 일반적으로 key 값으로 data access하는 방식.

#######################################################################################



