# -*- coding: utf-8 -*-
"""20200629-DL-Keras-XOR_dropout_customLoss_innerFunction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F1kcmUwcqSBJakILyAx7KIMwyjS5GZVB

# Custom Loss Function + inner function
* 다른 인자 활용하여 loss function을 적용하고 싶을 때
* `fit`이 수행해서 나오는 결과 부분은 건드리면 안 됨.
* 내가 사용하고 싶은 변수를 활용해서 inner function을 만든다.
"""

# module import
from tensorflow.keras.layers import Input, Dense, Dropout
import tensorflow.keras.backend as K
from tensorflow.keras.models import Model
from tensorflow.keras import optimizers
from tensorflow.keras import regularizers
import numpy as np

# data
X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]], dtype=np.float32)
y = np.array([[0], [1], [1], [0]], dtype=np.float32)

# custom loss function: inner function
def myLoss(r):
    def loss(y_true, y_pred):    
        BCE = -K.mean(
            y_true * K.log(y_pred + 1e-6) +
            (1-y_true) * K.log(1 - y_pred + 1e-6)
            )
        MSE = K.mean(K.square(y_true - y_pred))
        return r * BCE + (1-r) * MSE
    return loss # 함수를 return 한다.

# layers
X_input = Input(batch_shape=(None, 2))
X_hidden = Dense(4, activation='sigmoid')(X_input) # 데이터가 적어서 오히려 regularize하면 안 좋다. 그래서 매우 작은 수를 넣는다.
X_hidden = Dropout(rate=0.1)(X_hidden) # fit에만 적용, predict에서는 알아서 적용 안 됨.
y_output = Dense(1, activation='sigmoid')(X_hidden)

# model
model = Model(X_input, y_output)
model.compile(loss=myLoss(0.8), optimizer=Adam(lr=0.05))
print(model.summary())

# train
model.fit(X, y, epochs=500, batch_size=4)

# predict
y_hat = model.predict(X)
y_hat_pred = np.where(y_hat > 0.5, 1, 0)
print(y_hat)
print(y_hat_pred)